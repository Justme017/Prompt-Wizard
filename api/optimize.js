// Simple token approximation (works reliably in serverless)
function approximateTokens(text) {
  if (!text || text.trim().length === 0) return 0;
  // Rough estimation: ~4 chars per token for English text
  return Math.ceil(text.trim().length / 4);
}

const MODELS = {
  // OpenAI
  "gpt-4": { priceIn: 30 / 1e6, provider: "openai" },
  "gpt-3.5": { priceIn: 2 / 1e6, provider: "openai" },
  // Anthropic
  "claude-3": { priceIn: 15 / 1e6, provider: "anthropic" },
  "claude-2": { priceIn: 8 / 1e6, provider: "anthropic" },
  // Google
  "gemini-pro": { priceIn: 0.5 / 1e6, provider: "google" },
  "gemini-ultra": { priceIn: 5 / 1e6, provider: "google" },
  // Meta
  "llama-3": { priceIn: 0.5 / 1e6, provider: "meta" },
  // Mistral
  "mistral": { priceIn: 0.3 / 1e6, provider: "mistral" }
};

/* ---------------- FORMATTING ---------------- */

function formatAsMarkdown(text) {
  // Convert to markdown format
  return `# Optimized Prompt\n\n${text}\n\n---\n*Generated by Prompt Optimizer*`;
}

function formatAsJSON(text) {
  // Convert to JSON format
  return JSON.stringify({
    optimizedPrompt: text,
    timestamp: new Date().toISOString(),
    generatedBy: "Prompt Optimizer"
  });
}

function formatAsYAML(text) {
  // Simple YAML format
  return `optimizedPrompt: "${text.replace(/"/g, '\\"')}"\ntimestamp: ${new Date().toISOString()}\ngeneratedBy: Prompt Optimizer`;
}

/* ---------------- COMPRESSION ---------------- */

function compress(prompt, mode, format) {
  let optimized = prompt.trim();

  // Basic optimizations
  const lowerPrompt = optimized.toLowerCase();

  // Add context based on prompt type
  if (lowerPrompt.includes("code") || lowerPrompt.includes("program") || lowerPrompt.includes("function")) {
    optimized = `Write clean, efficient, well-commented code. Include error handling: ${optimized}`;
  } else if (lowerPrompt.includes("write") || lowerPrompt.includes("create") || lowerPrompt.includes("generate")) {
    optimized = `Write comprehensive, well-structured content: ${optimized}`;
  } else if (lowerPrompt.includes("explain") || lowerPrompt.includes("describe")) {
    optimized = `Provide clear, detailed explanation: ${optimized}`;
  } else if (lowerPrompt.includes("analyze") || lowerPrompt.includes("review")) {
    optimized = `Provide thorough analysis with specific examples: ${optimized}`;
  } else if (lowerPrompt.includes("question") || lowerPrompt.includes("answer")) {
    optimized = `Provide comprehensive answer with reasoning and supporting evidence: ${optimized}`;
  } else if (lowerPrompt.includes("list") || lowerPrompt.includes("steps")) {
    optimized = `Provide numbered list or step-by-step guide: ${optimized}`;
  }

  // Add output format hints
  if (lowerPrompt.includes("list") || lowerPrompt.includes("steps") || lowerPrompt.includes("guide")) {
    optimized += ". Format as numbered steps.";
  } else if (lowerPrompt.includes("compare") || lowerPrompt.includes("vs")) {
    optimized += ". Use table or structured comparison format.";
  } else if (lowerPrompt.includes("pros") || lowerPrompt.includes("cons")) {
    optimized += ". Structure as advantages and disadvantages.";
  }

  // Apply mode-specific enhancements
  if (mode === "strict") {
    optimized = `Be precise and factual: ${optimized}`;
  } else if (mode === "balanced") {
    optimized = `Provide accurate, helpful response: ${optimized}`;
  } else if (mode === "creative") {
    optimized = `Be innovative and comprehensive: ${optimized}`;
  }

  // Apply formatting
  switch (format) {
    case "markdown":
      optimized = formatAsMarkdown(optimized);
      break;
    case "json":
      optimized = formatAsJSON(optimized);
      break;
    case "yaml":
      optimized = formatAsYAML(optimized);
      break;
    case "plain":
    default:
      // No additional formatting
      break;
  }

  return optimized;
}

function recommendedMode(prompt) {
  const p = prompt.toLowerCase();
  if (p.match(/code|debug|program|function|algorithm|syntax/)) return "strict";
  if (p.match(/explain|describe|how|what|why|analyze|review|compare/)) return "balanced";
  if (p.match(/brainstorm|idea|story|creative|write|generate|design/)) return "creative";
  if (p.match(/summarize|concise|brief|short/)) return "strict";
  return "balanced";
}

/* ---------------- HANDLER ---------------- */

module.exports = async function handler(req, res) {
  console.log('API called with method:', req.method);
  console.log('Request body:', req.body);

  if (req.method !== "POST") {
    return res.status(405).json({ error: "POST only" });
  }

  const { prompt, model, mode, format = "plain" } = req.body;

  if (!prompt || typeof prompt !== 'string' || prompt.trim().length === 0) {
    return res.status(400).json({ error: "Valid prompt is required" });
  }

  if (!model || !MODELS[model]) {
    return res.status(400).json({ error: "Valid model is required" });
  }

  const finalMode = mode === "recommended" ? recommendedMode(prompt) : mode;

  if (!["strict", "balanced", "creative"].includes(finalMode)) {
    return res.status(400).json({ error: "Invalid mode" });
  }

  try {
    const optimized = compress(prompt, finalMode, format);
    const tokens = approximateTokens(optimized);
    const cost = tokens * (MODELS[model]?.priceIn || 0);

    res.status(200).json({
      optimized,
      tokens,
      cost: cost.toFixed(6),
      modeUsed: finalMode,
      format
    });
  } catch (error) {
    console.error('Error processing request:', error);
    res.status(500).json({ error: "Internal server error" });
  }
}
