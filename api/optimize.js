import { encoding_for_model } from "tiktoken";

/* ---------------- MODEL CONFIG ---------------- */

const MODELS = {
  // OpenAI
  "gpt-4": { priceIn: 30 / 1e6, provider: "openai" },
  "gpt-3.5": { priceIn: 2 / 1e6, provider: "openai" },
  // Anthropic
  "claude-3": { priceIn: 15 / 1e6, provider: "anthropic" },
  "claude-2": { priceIn: 8 / 1e6, provider: "anthropic" },
  // Google
  "gemini-pro": { priceIn: 0.5 / 1e6, provider: "google" },
  "gemini-ultra": { priceIn: 5 / 1e6, provider: "google" },
  // Meta
  "llama-3": { priceIn: 0.5 / 1e6, provider: "meta" },
  // Mistral
  "mistral": { priceIn: 0.3 / 1e6, provider: "mistral" }
};

/* ---------------- TOKENIZERS ---------------- */

function openAITokens(text, model) {
  try {
    const enc = encoding_for_model(model.startsWith("gpt") ? "gpt-4" : "cl100k_base");
    const tokens = enc.encode(text).length;
    enc.free();
    return tokens;
  } catch {
    return text.trim().split(/\s+/).length * 1.3; // approximate
  }
}

// Placeholder: approximate for non-OpenAI models
function approximateTokens(text) {
  return Math.ceil(text.trim().split(/\s+/).length * 1.3);
}

/* ---------------- FORMATTING ---------------- */

function formatAsMarkdown(text) {
  // Convert to markdown format
  return `# Optimized Prompt\n\n${text}\n\n---\n*Generated by Prompt Optimizer*`;
}

function formatAsJSON(text) {
  // Convert to JSON format
  return JSON.stringify({
    optimizedPrompt: text,
    timestamp: new Date().toISOString(),
    generator: "Prompt Optimizer"
  }, null, 2);
}

function formatAsYAML(text) {
  // Convert to YAML format
  return `optimizedPrompt: "${text.replace(/"/g, '\\"')}"\ntimestamp: ${new Date().toISOString()}\ngenerator: Prompt Optimizer`;
}

/* ---------------- COMPRESSION ---------------- */

function compress(prompt, mode, format = "plain") {
  let optimized = prompt
    // Basic cleanup
    .replace(/\s+/g, " ")
    .replace(/\n+/g, " ")
    .trim();

  // Remove common filler words and phrases
  const fillers = /\b(please|kindly|very|really|so|just|actually|basically|essentially|literally|honestly|truly|absolutely|completely|totally|extremely|quite|rather|somewhat|fairly|pretty|really)\b/gi;
  optimized = optimized.replace(fillers, "");

  // Remove redundant phrases
  optimized = optimized.replace(/\b(i want you to|i need you to|i would like you to)\b/gi, "");
  optimized = optimized.replace(/\b(can you please|could you please)\b/gi, "");
  optimized = optimized.replace(/\b(make sure to|be sure to|remember to)\b/gi, "");

  // Shorten common constructions
  optimized = optimized.replace(/\b(do not|don't)\b/gi, "avoid");
  optimized = optimized.replace(/\b(it is|it's)\b/gi, "is");
  optimized = optimized.replace(/\b(there is|there's)\b/gi, "is");
  optimized = optimized.replace(/\b(there are|there're)\b/gi, "are");

  // Clean up extra spaces again
  optimized = optimized.replace(/\s+/g, " ").trim();

  // Apply intelligent prompt engineering based on content
  const lowerPrompt = optimized.toLowerCase();

  if (lowerPrompt.includes("code") || lowerPrompt.includes("program") || lowerPrompt.includes("function")) {
    optimized = `Write clean, efficient, well-commented code. Include error handling: ${optimized}`;
  } else if (lowerPrompt.includes("explain") || lowerPrompt.includes("describe")) {
    optimized = `Explain step-by-step with examples and clear reasoning: ${optimized}`;
  } else if (lowerPrompt.includes("analyze") || lowerPrompt.includes("review")) {
    optimized = `Provide detailed analysis with evidence, pros/cons, and recommendations: ${optimized}`;
  } else if (lowerPrompt.includes("summarize") || lowerPrompt.includes("summary")) {
    optimized = `Create concise summary with key points, main ideas, and conclusions: ${optimized}`;
  } else if (lowerPrompt.includes("write") || lowerPrompt.includes("create") || lowerPrompt.includes("generate")) {
    optimized = `Write original, engaging, well-structured content with clear introduction and conclusion: ${optimized}`;
  } else if (lowerPrompt.includes("question") || lowerPrompt.includes("answer")) {
    optimized = `Provide comprehensive answer with reasoning and supporting evidence: ${optimized}`;
  } else if (lowerPrompt.includes("list") || lowerPrompt.includes("steps")) {
    optimized = `Provide numbered list or step-by-step guide: ${optimized}`;
  }

  // Add output format hints
  if (lowerPrompt.includes("list") || lowerPrompt.includes("steps") || lowerPrompt.includes("guide")) {
    optimized += ". Format as numbered steps.";
  } else if (lowerPrompt.includes("compare") || lowerPrompt.includes("vs")) {
    optimized += ". Use table or structured comparison format.";
  } else if (lowerPrompt.includes("pros") || lowerPrompt.includes("cons")) {
    optimized += ". Structure as advantages and disadvantages.";
  }

  // Apply mode-specific enhancements
  if (mode === "strict") {
    optimized = `Be precise and factual: ${optimized}`;
  } else if (mode === "balanced") {
    optimized = `Provide accurate, helpful response: ${optimized}`;
  } else if (mode === "creative") {
    optimized = `Be innovative and comprehensive: ${optimized}`;
  }

  // Apply formatting
  switch (format) {
    case "markdown":
      optimized = formatAsMarkdown(optimized);
      break;
    case "json":
      optimized = formatAsJSON(optimized);
      break;
    case "yaml":
      optimized = formatAsYAML(optimized);
      break;
    case "plain":
    default:
      // No additional formatting
      break;
  }

  return optimized;
}

function recommendedMode(prompt) {
  const p = prompt.toLowerCase();
  if (p.match(/code|debug|program|function|algorithm|syntax/)) return "strict";
  if (p.match(/explain|describe|how|what|why|analyze|review|compare/)) return "balanced";
  if (p.match(/brainstorm|idea|story|creative|write|generate|design/)) return "creative";
  if (p.match(/summarize|concise|brief|short/)) return "strict";
  return "balanced";
}

/* ---------------- HANDLER ---------------- */

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "POST only" });
  }

  const { prompt, model, mode, format = "plain" } = req.body;

  const finalMode =
    mode === "recommended" ? recommendedMode(prompt) : mode;

  const optimized = compress(prompt, finalMode, format);

  let tokens;
  const provider = MODELS[model]?.provider;
  if (provider === "openai") {
    tokens = openAITokens(optimized, model);
  } else {
    tokens = approximateTokens(optimized);
  }

  const cost = tokens * (MODELS[model]?.priceIn || 0);

  res.status(200).json({
    optimized,
    tokens,
    cost: cost.toFixed(6),
    modeUsed: finalMode,
    format
  });
}
